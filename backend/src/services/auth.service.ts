import {
  Injectable,
  ConflictException,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';
import { auth, firestore } from '../config/firebase';
import { PrismaService } from './prisma.service';
import { UserRepository } from '../repositories/user.repository';
import { User } from '@prisma/client';
import axios from 'axios';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private userRepository: UserRepository,
  ) {}

  // Type guard to check if error is an Axios error
  private isAxiosError(error: any): error is { response?: { status: number } } {
    return error && typeof error === 'object' && 'response' in error;
  }

  // ======================================================
  // üîπ ƒêƒÉng k√Ω (c√≥ th·ªÉ c√≥ ho·∫∑c kh√¥ng upload avatar)
  // ======================================================
  async register(
    email: string,
    password: string,
    name: string,
    phone?: string,
    avatarPath?: string,
    dob?: Date,
    gender?: 'MALE' | 'FEMALE' | 'OTHER',
  ): Promise<User> {
    try {
      const existingUser = await this.userRepository.findByEmail(email);
      if (existingUser) {
        throw new ConflictException('Email ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω');
      }

      const userRecord = await auth.createUser({
        email,
        password,
        displayName: name,
      });

      await firestore.collection('users').doc(userRecord.uid).set({
        name,
        email,
        phone,
        avatar: avatarPath ?? 'uploads/avatars/default.png',
        dob: dob || null,
        gender: gender || 'OTHER',
        createdAt: new Date(),
      });

      const passengerRole = await this.prisma.role.findUnique({
        where: { name: 'PASSENGER' },
      });

      if (!passengerRole) {
        throw new Error('Role PASSENGER not found');
      }

      const newUser = await this.userRepository.createUser({
        uid: userRecord.uid,
        name,
        email,
        phone,
        isActive: true,
        roleId: passengerRole.id,
        avatar: avatarPath ?? 'uploads/avatars/default.png',
        dob,
        gender,
      });

      return newUser;
    } catch (error) {
      if (error instanceof ConflictException) throw error;
      throw new Error(`Registration failed: ${error.message}`);
    }
  }

  // ======================================================
  // üîπ ƒêƒÉng nh·∫≠p
  // ======================================================
  async login(
    email: string,
    password: string,
  ): Promise<{
    idToken: string;
    uid: string;
    user: User & { role?: { id: number; name: string } };
  }> {
    try {
      const response = await axios.post<{
        idToken: string;
        localId: string;
      }>(
        `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${process.env.FIREBASE_API_KEY}`,
        {
          email,
          password,
          returnSecureToken: true,
        },
      );

      const { idToken, localId: uid } = response.data;

      const user = await this.prisma.user.findUnique({
        where: { email },
        include: { role: true },
      });

      if (!user) throw new NotFoundException('Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i');

      const baseUrl = 'http://10.0.2.2:3000';
      const avatarUrl = user.avatar
        ? `${baseUrl}/${user.avatar.replace(/\\/g, '/')}`
        : `${baseUrl}/uploads/avatars/default.png`;

      return {
        idToken,
        uid,
        user: {
          ...user,
          avatar: avatarUrl,
          role: user.role ? { id: user.role.id, name: user.role.name } : undefined,
        },
      };
    } catch (error) {
      if (this.isAxiosError(error) && error.response?.status === 400) {
        throw new UnauthorizedException('Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ch√≠nh x√°c');
      }
      throw new Error(`Login failed: ${error.message}`);
    }
  }

  // ======================================================
  // üîπ Qu√™n m·∫≠t kh·∫©u
  // ======================================================
  async forgotPassword(
    email: string,
  ): Promise<{ message: string; resetLink: string }> {
    try {
      const userRecord = await auth.getUserByEmail(email);
      if (!userRecord) throw new NotFoundException('Email ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω');

      const resetLink = await (auth as any).generatePasswordResetLink(email);

      return {
        message: 'Link ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c g·ª≠i',
        resetLink,
      };
    } catch (error) {
      throw new Error(`Forgot password failed: ${error.message}`);
    }
  }

  // ======================================================
  // üîπ ƒê·ªïi m·∫≠t kh·∫©u
  // ======================================================
  async changePassword(
    uid: string,
    newPassword: string,
  ): Promise<{ message: string }> {
    try {
      await auth.updateUser(uid, { password: newPassword });
      return { message: 'ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng' };
    } catch (error) {
      throw new Error(`Change password failed: ${error.message}`);
    }
  }

  // ======================================================
  // üîπ Reset m·∫≠t kh·∫©u
  // ======================================================
  async resetPassword(
    email: string,
    newPassword: string,
  ): Promise<{ message: string }> {
    try {
      const userRecord = await auth.getUserByEmail(email);
      if (!userRecord) throw new NotFoundException('Email kh√¥ng t·ªìn t·∫°i');

      await auth.updateUser(userRecord.uid, { password: newPassword });
      return { message: 'ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng' };
    } catch (error) {
      throw new Error(`Reset password failed: ${error.message}`);
    }
  }

  async findUserByUid(uid: string): Promise<User> {
    const user = await this.userRepository.findByUid(uid);
    if (!user) throw new NotFoundException('Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i');
    return user;
  }

  async updateUserProfile(
    id: number,
    data: { name?: string; phone?: string; dob?: Date; gender?: 'MALE' | 'FEMALE' | 'OTHER' },
  ): Promise<User> {
    const updatedUser = await this.userRepository.updateUser(id, data);
    return updatedUser;
  }
}